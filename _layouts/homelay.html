---
layout: default
---

<style>
/* 전체 마진 조정(원래 코드 유지) */
.margintop {
    margin-top: -20px;
}

/* 비디오를 겹치기 위한 컨테이너 */
.video-container {
    position: relative;
    width: 100%;
    aspect-ratio: 1280 / 880;
    overflow: hidden;
}

/* 비디오들을 컨테이너에 겹치기 */
.video-container video {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover; /* 필요하면 contain으로 바꿀 수 있음 */
    /* 비디오 위 텍스트 클릭 방지 등 고려시 pointer-events 사용 가능 */
}

/* fade 클래스 (opacity 전환) */
.fade-video {
    opacity: 0;
    transition: opacity 0.8s ease-in-out; /* duration은 JS와 동일하게 사용 */
    will-change: opacity;
    backface-visibility: hidden;
}

.fade-video.visible {
    opacity: 1;
}
</style>

<div>
    <div class="text-center mb-3"> {{ content | raw }} </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const container = document.querySelector('.video-container');
    const v1 = document.getElementById('video1');
    const v2 = document.getElementById('video2');

    if (!container || !v1 || !v2) {
        // 비디오가 없으면 아무 작업도 안 함
        return;
    }

    // 페이드 지속시간(ms) — CSS transition과 동일하게 유지
    const FADE_MS = 800;

    // 초기 클래스 세팅 (video1이 기본 visible 이라 가정)
    v1.classList.add('fade-video', 'visible');
    v2.classList.add('fade-video');

    // 초기 display 세팅: v1 보이게, v2 숨김 (display:block/none은 전환 완료 시 사용)
    v1.style.display = 'block';
    v2.style.display = 'none';

    // 컨테이너 높이 계산 함수: 현재 컨테이너 폭 기준으로
    function updateContainerHeight() {
        const width = container.clientWidth || container.offsetWidth;
        let h1 = 0, h2 = 0;

        if (v1.videoWidth && v1.videoHeight) {
            h1 = (v1.videoHeight / v1.videoWidth) * width;
        }
        if (v2.videoWidth && v2.videoHeight) {
            h2 = (v2.videoHeight / v2.videoWidth) * width;
        }

        // 만약 아직 메타데이터가 없어서 둘 다 0이면 리턴(메타데이터 로드 대기)
        if (h1 === 0 && h2 === 0) return;

        const maxH = Math.max(h1 || 0, h2 || 0);
        container.style.height = Math.ceil(maxH) + 'px';
    }

    // 메타데이터 로드될 때마다 높이 갱신
    v1.addEventListener('loadedmetadata', updateContainerHeight);
    v2.addEventListener('loadedmetadata', updateContainerHeight);

    // 이미 메타데이터가 로드된 경우 즉시 계산
    // (일부 브라우저에서 loadedmetadata가 이미 발생했을 수 있음)
    if (v1.readyState >= 1 || (v1.videoWidth && v1.videoHeight)) updateContainerHeight();
    if (v2.readyState >= 1 || (v2.videoWidth && v2.videoHeight)) updateContainerHeight();

    // 반응형: 창 크기 변경 시 재계산 (디바운스 간단 구현)
    let resizeTimer = null;
    window.addEventListener('resize', () => {
        if (resizeTimer) clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
            updateContainerHeight();
            resizeTimer = null;
        }, 120);
    });

    // CPU 효율 유틸: 숨길 비디오는 pause + reset, 표시 비디오는 play
    function finalizeHideVideo(vid) {
        // display:none으로 완전히 숨기고 재생 포지션 초기화
        vid.style.display = 'none';
        try {
            vid.pause();
            vid.currentTime = 0;
        } catch (e) {
            // 일부 브라우저/권한 문제 무시
            console.warn('video reset failed', e);
        }
    }

    function showVideoAndPlay(vidToShow, vidToHide) {
        // 먼저 display를 보이게 해서 opacity transition이 적용되도록 함
        vidToShow.style.display = 'block';
        // 강제로 reflow 시켜 CSS 변경을 인식하게 함 (안정성)
        // eslint-disable-next-line no-unused-expressions
        vidToShow.offsetHeight;

        // 페이드: 보이는 쪽에 visible 클래스 추가, 숨길 쪽은 제거
        vidToShow.classList.add('visible');
        vidToHide.classList.remove('visible');

        // 재생 준비
        try {
            vidToShow.currentTime = 0;
            const playPromise = vidToShow.play();
            // play()가 Promise를 반환하면 오류를 잡을 수 있음
            if (playPromise && typeof playPromise.then === 'function') {
                playPromise.catch(err => {
                    // 자동재생 정책 등으로 play 실패 시 콘솔만 출력
                    console.warn('play failed:', err);
                });
            }
        } catch (e) {
            console.warn('play error', e);
        }

        // FADE_MS 이후에 완전히 숨기고 reset
        setTimeout(() => finalizeHideVideo(vidToHide), FADE_MS);
    }

    // 이벤트: 영상이 끝나면 서로 전환
    v1.addEventListener('ended', function() {
        showVideoAndPlay(v2, v1);
    });

    v2.addEventListener('ended', function() {
        showVideoAndPlay(v1, v2);
    });

    // 안전: 페이지 로드 시 v1만 재생되도록 보장 (autoplay는 home.md에서만 설정)
    // 단, 경우에 따라 브라우저가 자동재생을 차단할 수 있으므로 play 실패는 무시
    try {
        v1.currentTime = 0;
        const p = v1.play();
        if (p && typeof p.then === 'function') {
            p.catch(() => {/* ignore autoplay restrictions */});
        }
    } catch (e) {
        // ignore
    }
});
</script>
